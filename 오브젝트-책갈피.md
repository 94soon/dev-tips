# 오브젝트 책갈피

![https://wikibook.co.kr/object/](https://wikibook.co.kr/images/cover/l/9791158391409.jpg)

[책](https://wikibook.co.kr/object/)은 기대만큼 너무나도 ~~좋다.~~ 좋을 것이다.(아직 다 본 건 아니므로..)

학습 효과의 극대화를 위해 책갈피로 남겨두고 가능하다면 조금 다른 생각, 다른 표현도 곁들여보자.

책의 내용은 다음과 같이 표시하고,

>책 내용 (거의) 그대로

덧붙이거나 다른 생각은 

- 덧붙임
- 다른 생각

으로 표시한다.

격리를 위해 사용되는 일반적인 의미의 인터페이스는 `인터페이스`로, 자바의 interface는 `interface`로 표기한다.

## 01. 객체, 설계

### p13

- `Theater.enter(Audience)` 보다는 `Theater.receive(Audience)`가 나을 듯

### p14

- 모듈의 3가지 기능?속성? by Robert C. Martin

  >- 실행 중 정상 동작
  >- 낮은 변경 비용
  >- 낮은 의사소통 비용

- 실행 중 정상 동작
  - 테스트로 보장
- 낮은 변경 비용
  - 불필요한 의존 관계 제거를 통해 달성
  - 의존의 반대말은 독립
  - 언제 독립 시키나? 믿을만한 자율성이 있을 때
  - 따라서 객체에게 믿을만한 자율성을 줘야 독립시키고 불필요한 의존 관계를 제거할 수 있다.
- 낮은 의사소통 비용
  - 관습, 규약, 패턴
  - 코드 리뷰

### p20

- 캡슐화
  
  >개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 **캡슐화(encapsulation)**라고 부른다.

  - 캡슐화를 잘 하면 객체 내부 세부 사항이 감춰지는 효과가 나지만, 그렇다고 세부 사항을 감추는 것을 캡슐화라고 부르는 게 적절한가?
  - 이보다는 Holub on Patterns의 역자주 내용을 참고해서 캡슐화와 은닉을 구분하는 게 좋을 듯
    - 캡슐화(encapsulation)
      - 데이터와 연산을 한데 묶어서 스스로 처리하면서 자율성 확보
      - 흘러다니는 데이터의 양/종류와 결합도는 보통 비례하는데 데이터와 연산을 한데 묶어서 결합도 증가를 막아주는 장치
      - 주로 클래스와 관련이 깊다
    - 정보 감춤/숨김/은닉(information hiding)
      - 내부를 감춤으로써 자율성의 훼손을 방지하고
      - 자율성 훼손 방지를 통해 결합도 증가를 막아주는 장치
      - 주로 접근 지정자(public, protected, private 등) 및 인터페이스와 관련이 깊다

### p25

- 객체 지향 설계 개선 방향

  >우리는 객체의 자율성을 높이는 방향으로 설계를 개선했다. 그 결과 이해하기 쉽고 유연한 설계를 얻을 수 있었다.

### p26

- 응집도

  >밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 말한다.
  
  - 응집도에 위임 개념이 반드시 들어가야할까?
  - 객체 자신이 소유하고 있는 데이터를 많이 활용하면서 동작하는 객체는 위임하지 않더라도 응집도가 높다.
  - 소유하고 있지만 활용되지 않는 데이터가 많으면 응집도가 낮아지며, 이를 소유하지 않고 외부로 옮겨서 위임하면 응집도가 높아진다.
  - 객체 자신이 소유하고 있지 않은 데이터를 많이 활용하면서 동작하는, 다시 말해 다른 객체에게 데이터를 요구하는 방식으로 동작하는 객체는 결합도가 높다.

- 절차적 프로그래밍

  >프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라 한다.

- 절차적 프로그래밍과 직관

  >일반적으로 절차적 프로그래밍은 우리의 직관에 위배된다. 우리는 관람객과 판매원이 자신의 일을 스스로 처리할 것이라고 예상한다.

  - 다른 관점에서 보면 절차적 프로그래밍은 우리의 직관에 위배되는 것이 아니라, 우리의 직관을 그대로 옮긴다.
    - 영화관 입장이라는 처리 흐름 관점에서는 관람객, 판매원, 극장 등의 자율성 있는 객체의 협력망을 떠올리기보다는 금액, 티켓, 차감 등 데이터와 동작을 처리 흐름에 따라 절차적으로 나열하는 것이 더 직관에 부합한다.
    - 또한 무생물인 극장, 매표소 등이 자율적으로 동작한다고 생각하는 것 역시 직관에 부합하지 않는다.
    - 이처럼 절차적 프로그래밍이 직관에 더 부합하기 때문에 객체 지향 프로그래밍보다 더 먼저 정립된 것이 아닐까.

### p27

- 객체지향 프로그래밍

  >데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다.

  - 연관된 데이터와 프로세스를 하나의 자율적인 객체로 캡슐화해서 절차의 나열이 아니라 객체의 협력을 통해 문제를 해결하는 프로그래밍 방식을 객체지향 프로그래밍이라고 부른다.

### p29

- 캡슐화와 정보 은닉

  >예제에서 결합도를 낮추기 위해 선택한 방법은 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하는 것이다.

  - 어쩌면 이 책에서는 캡슐화와 정보 은닉(information hiding)을 일부러 캡슐화 하나로 퉁친 듯. 정보 은닉(또는 감춤)이 용어 자체로도 불필요한 것을 감춘다는 의미를 더 구체적으로 전달하므로 캡슐화보다 전달력이 더 좋다고 생각.

### p34

- 객체지향은 실세계를 그대로 반영?

  >실세계에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다.

  - 객체지향은 실세계를 그대로 반영하지 않으며, 무생물을 자율적인 존재로 의인화하는 과정이 필요.

### p35

- 좋은 설계란?

  >오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계

### p36

- 좋은 객체지향 설계란?

  >협력하는 객체 사이의 의존성을 적절하게 관리하는 설계

  - 적절한 의존성에서의 적절은 양과 방향 관점으로 나눌 수 있다.
  - 객체의 자율성을 높이면 의존성의 양을 줄일 수 있다.
  - 의존성의 방향은 나중에 나올 듯



## 02. 객체지향 프로그래밍

### p41

- Object-oriented의 의미

  >진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
  >
  >어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
  >
  >객체지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라보기 바란다.
  >
  >객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라.

  - 객체는 자율성을 갖고 있고 내/외부가 격리돼있지만, 그렇다고 서로 떨어져 고립된 채 살아가는 존재가 아니다.
  - 먼저 객체를 식별하고 객체를 바탕으로 타입을 도출한다.

### p44

- 객체지향의 핵심

  >객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것
  
  - 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 협력망을 구성하는 것

### p45

- 접근 제어의 의의

  >변경될 가능성이 있는 세부적인 구현 내용을 private 영역 안에 감춤으로써 변경으로 인한 혼란을 최소화할 수 있다.

### p47

- 객체의 표현력

  >Long 타입은 변수의 크기나 연산자의 종류와 관련된 구현 관점의 제약은 표현할 수 있지만, Money 타입처럼 저장하는 값이 금액과 관련돼 있다는 의미를 전달할 수는 없다.  
  >또한 (Long 타입은) 금액 관련 로직이 (Long 안에 존재할 수 없으므로) 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없다. 
  >비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.

### p49

- 메시지

  >객체가 다른 객체와 상호작용할 수 있는 유일한 바업은 메시지를 전송(send a message)하는 것뿐이다.

  - 객체가 다른 객체화 협력할 수 있는 유일한 의사소통 수단은 메시징이다.

- 메서드

  >메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 (받은) 메시지를 처리할 방법을 결정한다. 이처럼 수신된 메시지를 처리하기 위한 (객체) 자신만의 방법을 메서드(method)라고 부른다.

  - 앨런 케이의 설명에 따르면 메시지에는 메서드만 대응되는 게 아니라 데이터도 대응될 수 있다. [객체 지향 프로그래밍과 메시징](https://homoefficio.github.io/2019/07/04/객체-지향-프로그래밍과-메시징/) 참고

### p57

- 컴파일 시간 의존성과 실행 시간 의존성

  - 컴파일 시점(Compile time) 의존성과 실행 시점(Runtime) 의존성

### p59

- 코드의 의존성과 실행 시점의 의존성

  >코드의 의존성(컴파일 시점 의존성)과 실행 시점(Runtime)의 의존성은 동일하지 않을 수 있다.

  - 코드 상에서는 수퍼클래스에 의존하지만 실행 시점에서는 구체적 서브클래스에 의존한다. 이를 가능하게 하는 것이 상속이다.

### p61

- 상속의 숨은 의의

  >상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
  >
  >인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하라. 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.

  - 상속하면 보통 public, protected인 메서드나 필드를 물려받는 것을 떠올리는데, 정작 중요한 것은 인터페이스를 물려받는 다는 것

### p62

- Upcasting

  >자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(Upcasting)이라고 부른다.

### p63

- 다형성(Polymorphism)

  >다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

  - 즉 어떤 받은 메시지에 대해 어떤 메서드를 통해 처리하고 응답할 지는 메시지를 실제로 받은 객체 스스로 결정한다.

- 동적 바인딩(Dynamic-binding), 지연 바인딩(Late-binding)

  >메시지와 메서드를 실행 시점에 바인딩하는 것

- 정적 바인딩(Static-binding), 초기 바인딩(Early-binding)

  >전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것

### p64

- 구현 상속과 인터페이스 상속

  >다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속(Interface inheritance) 또는 서브타이핑(Subtyping)이라고 부른다.

  - 동적 바인딩을 활용해서 다형적 협력을 구성하기 위해 인터페이스를 공유하는 상속을 인터페이스 상속 또는 서브타이핑이라고 부른다.

  >순수하게 코드를 재사용할 목적으로 상속을 사용하는 것을 구현 상속(Implementation inheritance) 또는 서브클래싱(Subclassing)이라고 부른다.

  - 인터페이스 공유가 필요한 부모 자식 관계가 아님에도 불구하고 그저 구현 내용을 상속을 통해 재사용하는 것을 구현 상속 또는 서브클래싱이라고 부른다.

### p65-p66

- 추상화의 힘

  >추상화 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
  >
  >추상화를 사용하면 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 한다.
  >
  >추상화를 이용한 설계는 필요에 따라 표현의 수준을 조정하는 것을 가능하게 해준다.
  >
  >추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.

  - 추상화는 의사소통에 필요하지 않은 세부 내용을 덜어내고 단순화하는 것을 말한다. 덜어낸다는 것은 결국 보여지지 않게 감추는 효과가 있으므로 추상화 역시 정보 감춤의 장점인 자율성과 유연성을 확보하는 데 도움이 된다.

  - 추상화를 통해 세부 구현 내용 없이 정책 수준에서 애플리케이션의 협력 흐름을 단순화해서 표현할 수 있다.

### p67

- 겉보기에 예외로 보이는 상황 해결

  ```java
  public class Movie {
    public Money calculateMovieFee(Screening screening) {
      if (discountPolicy == null) {
        return fee;
      }

      return fee.minus(discountPolicy.cacluateDiscountAmount(screening));
    }
  }
  ```
  
  >할인 정책이 없는 경우에는 할인 금액이 0이라는 사실을 결정하는 책임이 DiscountPolicy가 아닌 Movie 쪽에 있다.
  >
  >책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.

  - 할인 정책이 없는 경우를 특별한 케이스로 취급해서 Movie에게 책임을 부과하는 것보다, 할인 정책이 없는 것 자체를 하나의 할인 정책(NoneDiscountPolicy)으로 정의해서 할인 금액이 없음을 결정하는 책임을 Movie에서 DiscountPolicy로 옮기는 것이 좋다.

  - 현실에서는 할인 정책 자체가 존재하지 않는 케이스지만 객체지향 설계에서는 정책이 없는 게 아니라 할인 금액이 없는 하나의 정책으로 취급한다. 이런 점도 의인화와 함께 객체지향이 현실 세계를 있는 그대로 반영하는 것이 아니라는 증거가 된다.

### p68

- 이해가 잘 안 되는 부분

  >앞의 NoneDiscountPolicy 클래스의 코드를 자세히 살펴보면 getDiscountAmount() 메서드가 어떤 값을 반환하더라도 상관이 없다는 사실을 알 수 있다. (중략) NoneDiscountPolicy의 개발자는 getDiscountAmount()가 호출되지 않을 경우 DiscountPolicy가 0원을 반환할 것이라는 사실을 가정하고 있기 때문이다.

  - NoneDiscountPolicy 코드는 다음과 같은데 이 중 DiscountPolicy가 0원을 반환할 것이라는 사실을 가정하고 있는 부분이 있나?

    ```java
    public class NoneDiscountPolicy extends DiscountPolicy {
      @Override
      protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO;
      }
    }
    ```
### p70

- 잘 이해가 안 되는 상속이 캡슐화를 위반한다는 사례

  >상속의 가장 큰 문제점은 캡슐화를 위반한다는 것이다. 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다. AmountDiscountMovie와 PercentDiscountMovie를 구현하는 개발자는 부모 클래스인 Movie의 calculateMovieFee 메서드 안에서 추상 메서드인 getDiscountAmount 메서드를 호출한다는 사실을 알고 있어야 한다.

  - 여기에서도 캡슐화와 정보 감춤을 퉁쳐서 캡슐화라고 쓰고 있다. 앞에서도 언급했지만 이런 문맥에서는 캡슐화와 정보 감춤을 엄밀하게 나눠서 상속이 정보 감춤을 위반한다고 하는 게 불필요한 혼선을 막는 데 더 도움이 될 것 같다.

  - 서브클래스 입장에서, 자기가 override하고 있는 메서드가 '수퍼클래스의 어디에선가 호출된다'는 사실을 알고 있는 걸 '서브클래스가 수퍼클래스의 내부 구조를 잘 알고 있다'라고 해석해야할 필요가 있나 싶다.

    - 서브클래스 입장에서는 상속에 의해 자기가 구현해야할 메서드가 강제된 것 뿐이고, 이는 상속이 아니라 인터페이스를 구현할 때도 마찬가지다. 다만 한 가지 차이점은 상속에서는 서브클래스가 구현하는 메서드를 수퍼클래스가 호출한다는 점을 서브클래스가 알 수 있다는 점이고, 인터페이스 구현에서는 구현한 메서드를 누가 호출할지 모른다는 점이다.

    - 그런데 누가 호출할지 안다고 해도 그저 수퍼클래스가 호출할지 안다는 것 뿐이고, 수퍼클래스에서 내부적으로 어떻게 호출되는 지는 알 수 없다. 즉, 서브클래스가 구현한 메서드를 c()라고 할 때, a() -> b() -> c()로 호출될지 a() -> c()로 호출될지 서브클래스는 알 수 없다.

    - 따라서 최소한 책에서 예로든 메서드 관점에서는 서브클래스가 부모클래스의 내부 구조를 잘 알고 있다고 결론 짓는 건 적절하지 않아 보인다.

  - 상속이 잘못 사용되면 좋지 않은 이유는 abstract 등의 키워드를 통해 인터페이스를 공유하기 때문이 아니라, protected 등으로 서브클래스에게 공개하는 부분이 있고 이것이 정보 감춤을 위반하기 때문이다.

### p72

- 상속의 적절한 사용 사례

  >코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 옳지만,
  >다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다.

  - 구현을 재사용하기 위한 목적으로 상속을 사용하는 것은 강한 결합을 유발하므로 좋지 않다.
  - 다형성을 사용한 문제 해결이 필요한 상황에서 인터페이스 공유를 위해 상속을 사용하는 것은 괜찮다.
    - 단 이 경우에도 정보 감춤 위반을 최소화해야 한다.

