# Quartz 스케줄러 적용 아키텍처 개선 - 2

[1편](https://homoefficio.github.io/2019/09/28/Quartz-스케줄러-적용-아키텍처-개선-1/)에서는 Quartz 스케줄러 적용 시 변경 주기가 다른 스케줄러 모듈과 작업 클래스 모듈을 분리해서 클린 아키텍처에 다가가는 방법을 알아봤다.

분리된 작업 클래스 모듈은 DB 작업을 할 수도 있고, 하둡 인프라 관련 작업을 할 수도 있고, 알림 메일도 보내야하는 등 여러 작업을 할 수 있어야 한다. 그런데 작업 클래스 모듈은 말 그대로 작업 클래스만 모아 놓은 jar 라이브러리일 뿐이라서 JDBC 드라이버나 SMTP 메일 서버 설정 등을 포함하고 있지 않으며, 이런 것들을 스스로 가지고 있는 것 자체도 Single Responsibility Principle 관점에서 보면 적절하지 않다.

그래서 작업 클래스 모듈을 동적으로 로딩하는 스케줄러 모듈이 작업 클래스가 필요로 하는 컴포넌트를 주입해주는 구조로 구성할 수 있다면 가장 좋다. 즉, 다음과 같이 `@Autowire`를 통해 작업 클래스에 필요한 의존 관계를 주입해 줄 수 있다면 딱 좋다. 

![Imgur](https://i.imgur.com/mT6CfNb.png)

그런데 보통 `@Autowire`는 스프링 애플리케이션이 구동되면서 bean을 생성하고 객체 협력망을 구성할 때 작동한다. 지금처럼 스케줄러를 포함한 스프링 애플리케이션이 완전히 구동된 후에 동적으로 작업 클래스를 로딩할 때도 `@Autowire`를 통해 의존 관계 주입하는 것이 가능할까?

# SpringBeanJobFactory

결론부터 말하면 **스프링이 제공하는 `SpringBeanJobFactory`를 통해 애플리케이션 구동 완료 후에 동적으로 추가하는 bean에도 의존 관계를 쉽게 주입할 수 있다.** 

당연한 소리지만 스케줄러는 일반적으로 작업을 스케줄하는 시점과 작업을 실행하는 시점이 다르다. Quartz 스케줄러도 마찬가지며 스케줄하는 시점에도 작업 클래스를 로딩하지만 작업을 실행하는 시점에도 클래스를 로딩한다. 그리고 작업을 실행하려면 작업 클래스를 인스턴스화 해야 하는데, 이 때 [`JobFactory`](https://www.quartz-scheduler.org/api/2.3.1-SNAPSHOT/index.html)가 사용된다. 문서에도 나와있는 것처럼 `JobFactory`를 의존 관계 주입 통로로 사용할 수 있다.

스프링은 꽤 오래 전부터 Quartz를 지원해오고 있으며 스프링부트에도 quartz starter가 있고 그 안에 `JobFactory`를 구현한 `SpringBeanJobFactory`가 있다. 따라서 스프링부트를 통해 quartz를 사용하고 있다면, 작업 클래스도 일반적인 스프링 bean과 마찬가지로 간단하게 의존 관계 주입이 가능하다. 코드로 알아보자.

## 스케줄러 모듈에 HelloService 추가

다음과 같이 스케줄러 모듈에 `HelloService`를 추가한다.
